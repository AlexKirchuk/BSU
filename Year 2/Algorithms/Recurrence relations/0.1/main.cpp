/*
В одном очень длинном и узком пруду по кувшинкам прыгает лягушка.
Кувшинки в пруду расположены в один ряд.
Лягушка начинает прыгать с первой кувшинки ряда
и хочет закончить на последней.
Но в силу вредности характера лягушка согласна прыгать
только вперед через одну или через две кувшинки.
Например, с кувшинки номер 1 она может прыгнуть лишь
на кувшинки номер 3 и номер 4.

На некоторых кувшинках сидят комарики.
А именно, на i-й кувшинке сидят ai комаров.
Когда лягушка приземляется на кувшинку,
она съедает всех комариков, сидящих на ней.
Лягушка хочет спланировать свой маршрут так,
чтобы съесть как можно больше комаров.
Помогите ей: скажите, какие кувшинки она должна посетить на своем пути.

Input
Первая строка входа содержит n — число кувшинок в пруду (1 ≤ n ≤ 100 000).
Вторая строка содержит n чисел, разделенных одиночными пробелами.
i-е число сообщает, сколько комаров сидит на i-й кувшинке (1 ≤ i ≤ n).
Все числа целые, неотрицательные и не превосходят 1000.

Output
В первой строке выведите одно число — максимальное число комаров,
которые может съесть лягушка.
Во второй строке выведите последовательность чисел —
номера тех кувшинок, на которых должна побывать лягушка,
в возрастающем порядке. Если решений несколько, выведите любое.

Если лягушка не может добраться до последней кувшинки,
то выведите одно число −1.
*/

#include <iostream>
#include <vector>

int main() {
    long long n;
    std::cin >> n;

    long long* arr = new long long[n];
    for (long long i = 0; i < n; i++)
    {
        std::cin >> arr[i];
    }

    long long* maxMosq = new long long[n];
    for (long long i = 0; i < n; i++)
    {
        maxMosq[i] = -1;
    }

    long long* path = new long long[n];
    for (long long i = 0; i < n; i++)
    {
        path[i] = -1;
    }

    maxMosq[0] = arr[0];
    long long content;

    for (long long i = 0; i < n; i++)
    {
        if (maxMosq[i] == -1) continue;

        if (i + 2 <= n - 1)
        {
            content = maxMosq[i] + arr[i + 2];
            if (content > maxMosq[i + 2])
            {
                maxMosq[i + 2] = content;
                path[i + 2] = i;
            }
        }

        if (i + 3 <= n - 1)
        {
            content = maxMosq[i] + arr[i + 3];
            if (content > maxMosq[i + 3])
            {
                maxMosq[i + 3] = content;
                path[i + 3] = i;
            }
        }
    }

    if (maxMosq[n - 1] == -1)
    {
        std::cout << -1 << std::endl;
        return -1;
    }

    std::cout << maxMosq[n - 1] << std::endl;

    std::vector<long long> track;
    for (long long i = n - 1; i != -1; i = path[i])
    {
        track.push_back(i);
    }

    for (long long i = track.size() - 1; i >= 0; i--)
    {
        std::cout << track[i] + 1 << " ";
    }

    return 0;
}